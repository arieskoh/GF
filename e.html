<!DOCTYPE html>
<html>
<head>
    <title>家庭影院模型</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
        }

        #control-panel {
            width: 280px;
            height: 100vh;
            position: fixed;
            left: 0;
            top: 0;
            overflow-y: auto;  /* 新增滚动条 */
            overscroll-behavior: contain; /* 防止滚动穿透 */
            
            /* 移动端优化 */
            @media (max-width: 768px) {
                width: 100%;
                height: auto;
                position: relative;
                max-height: 60vh; /* 限制最大高度 */
            }
        }
        .mobile-toggle {
            display: none;
            position: fixed;
            left: 10px;
            top: 10px;
            z-index: 1000;
            padding: 8px 12px;
            background: #2196F3;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            
            @media (max-width: 768px) {
                display: block;
            }
        }

        /* 为Three.js画布添加响应式容器 */
        canvas {
            position: fixed !important;
            left: 280px;
            right: 0;
            width: calc(100% - 280px) !important;
            height: 100vh !important;
            @media (max-width: 768px) {
                left: 0;
                width: 100% !important;
                top: 400px; /* 给控制面板留出空间 */
                height: calc(100vh - 400px) !important;
            }
        }

        /* 信息面板响应式 */
        #model-info {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: flex;
            gap: 20px;
            z-index: 1000;
            max-width: 400px; /* 新增最大宽度限制 */
            width: auto; /* 改为自动宽度 */
        }

        /* 添加全局响应式基础 */
        body {
            overflow-x: hidden;
            min-width: 320px;
        }
        .info-section {
            flex: 1; /* 使子项等分空间 */
            min-width: 160px; /* 适当减小最小宽度 */
        }
         
        .info-section h3 {
            margin: 0 0 12px 0;
            color: #2196F3;
            font-size: 16px;
            border-bottom: 2px solid #BBDEFB;
            padding-bottom: 6px;
        }
         
        .info-row {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin: 8px 0;
        }
         
        .label {
            color: #616161;
            font-size: 14px;
        }
         
        .value {
            color: #1976D2;
            font-weight: 600;
            font-size: 15px;
            min-width: 60px;
            text-align: right;
        }
         
        .unit {
            color: #757575;
            font-size: 13px;
            margin-left: 4px;
        }

        .card {
            background: white;
            border-radius: 8px;
            margin-bottom: 10px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .card-header {
            font-weight: bold;
            background: #f8f9fa;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            user-select: none;
            position: relative;
            padding-right: 30px;
            background: #e3f2fd; /* 更醒目的浅蓝色背景 */
            color: #1976d2; /* 主题蓝色文字 */
            padding: 14px 20px;
            font-size: 1.1em;
            transition: all 0.3s ease;
            border-left: 4px solid #2196f3; /* 左侧装饰条 */
        }
        /* 添加文字提示 */
        .card-header::before {
            content: '点击折叠';
            position: absolute;
            right: 50px;
            font-size: 0.8em;
            color: #757575;
            font-style: italic;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .card-header:hover::before {
            opacity: 1;
        }

        .card-header::after {
            content: '';
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%) rotate(0deg);
            
            border-left: 2px solid #666;
            border-bottom: 2px solid #666;
            transform-origin: 50% 50%;

            border-left-color: #2196f3; /* 蓝色箭头 */
            border-bottom-color: #2196f3;
            width: 14px;
            height: 14px;
            transition: all 0.3s ease;
        }
        .card-header.collapsed::before {
            content: '点击展开';
        }
        .card-header.collapsed::after {
            transform: translateY(-50%) rotate(-45deg);
            border-left-color: #616161;
            border-bottom-color: #616161;
        }
        /* 折叠状态样式 */
        .card-header.collapsed {
            background: #f5f5f5; /* 折叠后变灰 */
            border-left-color: #9e9e9e;
        }

        .card-content {
            padding: 10px;
        }
        /* 悬停效果 */
        .card-header:hover {
            background: #bbdefb; /* 悬停时加深背景 */
            transform: translateX(3px);
        }



        .input-group input[type="number"] {
            padding: 6px 8px;
        }
        .input-group input[type="range"] {
            margin-top: 8px;
        }

        .input-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }
         
        .full-width {
            width: 100%;
        }
         
        .max-checkbox {
            white-space: nowrap;
            padding: 6px 0;
        }
        .select-wrapper {
            position: relative;
            width: 100%;
        }

        label {
            font-size: 0.9em;
            color: #333;
            display: block;
            margin-bottom: 4px;
        }

        input[type="number"] {
            width: 100%;
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }

        input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }

        /* 禁用状态样式 */
        input:disabled, select:disabled {
            background-color: #eee;
            cursor: not-allowed;
        }
         
        input[type="range"]:disabled {
            opacity: 0.5;
        }
         
        /* 过渡效果 */
        input, select {
            transition: all 0.3s ease;
        }

        .unit {
            color: #666;
            font-size: 0.8em;
        }

        .max-checkbox {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9em;
        }

        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .radio-group label {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .disabled {
            opacity: 0.6;
            pointer-events: none;
        }

        #screen-info {
            position: absolute;
            top: 10px;
            left: 300px;
            background: rgba(255,255,255,0.9);
            padding: 8px 12px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        /* 优化下拉框样式 */
        select#screenRatio {
            /* 基础样式 */
            width: 100%;
            padding: 8px 12px;
            font-size: 14px;
            border: 1px solid #BBDEFB;
            border-radius: 6px;
            background-color: #fff;
            color: #1976D2;
            transition: all 0.3s ease;
            
            /* 下拉箭头自定义 */
            appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%231976D2'%3e%3cpath d='M7 10l5 5 5-5z'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 18px;
            
            /* 悬停效果 */
            &:hover {
                border-color: #2196F3;
                box-shadow: 0 2px 6px rgba(33,150,243,0.1);
            }
            
            /* 聚焦状态 */
            &:focus {
                outline: none;
                border-color: #2196F3;
                box-shadow: 0 0 0 2px rgba(33,150,243,0.2);
            }
        }
         
        /* 下拉选项样式 */
        select#screenRatio option {
            padding: 10px 15px;
            background: white;
            color: #333;
            
            /* 悬停效果 */
            &:hover {
                background: #E3F2FD !important;
            }
        }
         
        /* 移动端优化 */
        @media (max-width: 768px) {
            select#screenRatio {
                padding: 10px 15px;
                font-size: 16px;
                background-size: 24px;
            }
        }
    </style>
</head>
<body>
    <div id="screen-info"></div>
    <div class="mobile-toggle" onclick="togglePanel()">▼ 控制面板</div>
    
    <div id="model-info">
        <div class="info-section">
            <h3>房间信息</h3>
            <div class="info-row">
                <span class="label">地面面积：</span>
                <span class="value" id="room-area">0.00</span>
                <span class="unit">m²</span>
            </div>
            <div class="info-row">
                <span class="label">空间容积：</span>
                <span class="value" id="room-volume">0.00</span>
                <span class="unit">m³</span>
            </div>
            <!-- 新增比例行 -->
            <div class="info-row">
                <span class="label">房间比例：</span>
                <span class="value" id="room-ratio">0:0:0</span>
            </div>
        </div>
        <div class="info-section">
            <h3>投影幕信息</h3>
            <div class="info-row">
                <span class="label">幕布宽度：</span>
                <span class="value" id="screen-width">0.00</span>
                <span class="unit">m</span>
            </div>
            <div class="info-row">
                <span class="label">幕布高度：</span>
                <span class="value" id="screen-height">0.00</span>
                <span class="unit">m</span>
            </div>
        </div>
    </div>
    <div id="control-panel">
        <!-- 房间尺寸设置 -->
        <div class="card">
            <div class="card-header">房间尺寸设置</div>
            <div class="card-content">
                <div class="input-group">
                    <label>长度 <span class="unit">(米)</span></label>
                    <input type="number" id="length" value="6.5" step="0.1">
                    <input type="range" id="length-range" min="1" max="10" step="0.1" value="6.5">
                </div>
                <div class="input-group">
                    <label>宽度 <span class="unit">(米)</span></label>
                    <input type="number" id="width" value="4.0" step="0.1">
                    <input type="range" id="width-range" min="1" max="10" step="0.1" value="4.0">
                </div>
                <div class="input-group">
                    <label>高度 <span class="unit">(米)</span></label>
                    <input type="number" id="height" value="2.8" step="0.1">
                    <input type="range" id="height-range" min="1" max="5" step="0.1" value="2.8">
                </div>
            </div>
        </div>

        <!-- 投影幕设置 -->
            <div class="card">
                <div class="card-header">投影幕设置</div>
                <div class="card-content">
                    <div class="input-group">
                        <label>尺寸 <span class="unit">(英寸)</span></label>
                        <div class="input-row">
                            <input type="number" id="screenSize" value="160" step="0.1" style="flex: 1;">
                        </div>
                        <input type="range" id="screenSize-range" min="30" max="500" step="1" value="120">
                    </div>

                    <div class="input-group">
                        <label>屏幕比例</label>
                        <select id="screenRatio" class="full-width">
                            <option value="16/9">16:9</option>
                            <option value="4/3">4:3</option>
                            <option value="16/10">16:10</option>
                            <option value="2.35/1">2.35:1</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label>边框宽度 <span class="unit">(cm)</span></label>
                        <div class="input-row">
                            <input type="number" id="screenBorderWidth" class="full-width" value="8" step="1">
                        </div>
                        <input type="range" id="screenBorderWidth-range" min="0" max="50" step="1" value="8">
                    </div>
                </div>
            </div>

        <!-- 音箱配置 -->
        <div class="card">
            <div class="card-header">音箱配置</div>
            <div class="card-content">
                <div class="radio-group">
                    <label><input type="radio" name="speakerConfig" value="5.1" checked> 5.1</label>
                    <label><input type="radio" name="speakerConfig" value="7.1"> 7.1</label>
                    <label><input type="radio" name="speakerConfig" value="5.1.2"> 5.1.2</label>
                    <label><input type="radio" name="speakerConfig" value="7.1.4" checked> 7.1.4</label>
                </div>
            </div>
        </div>

        <!-- 音箱摆位设置 -->
        <div class="card">
            <div class="card-header">音箱摆位设置</div>
            <div class="card-content">
                <div class="input-group">
                    <label>观影视角 <span class="unit">(°)</span></label>
                    <input type="number" id="viewAngle" value="45" min="25" max="180">
                    <input type="range" id="viewAngle-range" min="25" max="180" step="1" value="45">
                </div>
                <div class="input-group">
                    <label>听音高度 <span class="unit">(m)</span></label>
                    <input type="number" id="earHeight" value="1.2" step="0.01" min="0.1">
                    <input type="range" id="earHeight-range" min="0.1" max="5" step="0.01" value="1.2">
                </div>
                <div class="input-group">
                    <label>主音箱夹角 <span class="unit">(°)</span></label>
                    <input type="number" id="mainSpeakerAngle" value="41" min="25" max="60">
                    <input type="range" id="mainSpeakerAngle-range" min="25" max="60" step="0.1" value="41">
                </div>
                <div class="input-group">
                    <label>侧环绕夹角 <span class="unit">(°)</span></label>
                    <input type="number" id="sideSurroundAngle" value="90" min="75" max="110">
                    <input type="range" id="sideSurroundAngle-range" min="75" max="110" step="0.1" value="90">
                </div>
                <div class="input-group">
                    <label>后环绕夹角 <span class="unit">(°)</span></label>
                    <input type="number" id="rearSurroundAngle" value="60" min="45" max="150">
                    <input type="range" id="rearSurroundAngle-range" min="45" max="150" step="0.1" value="60">
                </div>
                <div class="input-group">
                    <label>前置天空声道夹角 <span class="unit">°</span></label>
                    <input type="number" id="frontSkyAngle" value="55" min="30" max="55">
                    <input type="range" id="frontSkyAngle-range" min="30" max="55" step="0.1" value="55">
                </div>
                <div class="input-group">
                    <label>后置天空声道夹角 <span class="unit">°</span></label>
                    <input type="number" id="rearSkyAngle" value="125" min="125" max="150">
                    <input type="range" id="rearSkyAngle-range" min="125" max="150" step="0.1" value="125">
                </div>

            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>

    <script>
        let scene, camera, renderer, controls;
        let labelRenderer;
        let currentRoom = null;
        let currentScreen = null;  
        let currentCenterSpeaker = null; 
        let currentLeftSpeaker = null;
        let currentRightSpeaker = null;
        let currentSLSpeaker = null;
        let currentSRSpeaker = null; 
        let currentSRLSpeaker = null; 
        let currentSRRSpeaker = null; 
        let currentTFLSpeaker = null; 
        let currentTFRSpeaker = null; 
        let currentTRLSpeaker = null; 
        let currentTRRSpeaker = null; 
        const screenInfoElement = document.getElementById('screen-info');
        let sphere; 

        // 添加音箱配置映射
        const speakerConfigMap = {
            '5.1': ['center', 'front-left', 'front-right', 'surround-left', 'surround-right'],
            '7.1': ['center', 'front-left', 'front-right', 'surround-left', 'surround-right', 'rear-left', 'rear-right'],
            '5.1.2': ['center', 'front-left', 'front-right', 'surround-left', 'surround-right', 'top-front-left', 'top-front-right'],
            '7.1.4': ['center', 'front-left', 'front-right', 'surround-left', 'surround-right', 'rear-left', 'rear-right', 
                      'top-front-left', 'top-front-right', 'top-rear-left', 'top-rear-right']
        };

        // 初始化场景

        document.addEventListener('DOMContentLoaded', function() {
            function init() {
                
                scene = new THREE.Scene();

                // 增强型照明系统
                const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
                hemisphereLight.position.set(0, 10, 0);
                scene.add(hemisphereLight);

                // 主摄像机设置
                camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(7, 5, 7);
                camera.lookAt(0, 0, 0);

                // WebGL渲染器配置
                renderer = new THREE.WebGLRenderer({antialias: true,alpha: true});
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0xF8F9FA, 1);
                document.body.appendChild(renderer.domElement);

                // 初始化CSS2D渲染器
                labelRenderer = new THREE.CSS2DRenderer();
                labelRenderer.setSize(window.innerWidth, window.innerHeight);
                labelRenderer.domElement.style.position = 'absolute';
                labelRenderer.domElement.style.top = '0';
                labelRenderer.domElement.style.pointerEvents = 'none';
                document.body.appendChild(labelRenderer.domElement);

                // 轨道控制器初始化
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;

                // 创建小黄色球体
                const sphereGeometry = new THREE.SphereGeometry(0.1, 32, 32);
                const sphereMaterial = new THREE.MeshPhongMaterial({ color: 0xffff00 });
                sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                scene.add(sphere);

                // 移动端自动折叠
                if (window.innerWidth < 768) {
                    document.getElementById('control-panel').classList.add('collapsed');
                }

                document.querySelectorAll('#screenRatio, #screenBorderWidth, #screenBorderWidth-range').forEach(element => {
                    element.addEventListener('change', () => generateModel());
                });

                 // 音箱配置变化监听
                document.querySelectorAll('input[name="speakerConfig"]').forEach(radio => {
                    radio.addEventListener('change', function() {
                        updateSpeakerVisibility(this.value);
                    });
                });

             
                // 屏幕比例变化事件
                document.getElementById('screenRatio').addEventListener('change', () => {
                    
                    generateModel();
                    
                    if (document.getElementById('maxScreen').checked) {
                        toggleMaxScreenMode(true);
                    }
                });


                //输入事件监听
                document.querySelectorAll('input[type="number"], input[type="range"]').forEach(input => {
                    input.addEventListener('input', function() {
                        // 同步双向数据
                        if (this.type === 'number') {
                            const range = document.getElementById(this.id + '-range');
                            if (range) range.value = this.value;
                        } else {
                            const number = document.getElementById(this.id.replace('-range', ''));
                            if (number) number.value = this.value;
                        }

                        // 根据输入项类型触发更新
                        if (this.id === 'viewAngle' || this.id === 'viewAngle-range') {
                            updateSpherePosition();
                            generateSPK(); // 关键：视角变化时更新音箱位置
                        } else {
                            generateModel(); // 其他参数变化时更新房间和屏幕
                        }
                        updateModelInfo();
                    });
                });

                document.querySelectorAll('#screenRatio, #screenBorderWidth, #screenBorderWidth-range').forEach(element => {
                    element.addEventListener('change', function() {
                        generateModel(); // 只需调用生成模型即可
                    });
                });


                // 卡片折叠功能
                document.querySelectorAll('.card-header').forEach(header => {
                    header.addEventListener('click', function() {
                        const content = this.nextElementSibling;
                        const isCollapsed = this.classList.toggle('collapsed');
                        
                        // 添加/移除collapsed类控制箭头方向
                        if (isCollapsed) {
                            content.style.display = 'none';
                        } else {
                            content.style.display = 'block';
                        }
                    });
                });
                // 窗口resize处理
                window.addEventListener('resize', onWindowResize, false);
                adjustPanelLayout();
            }

            // 窗口resize回调函数
            function onWindowResize() {
                // 更新相机
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                
                // 更新渲染器
                renderer.setSize(window.innerWidth, window.innerHeight);
                
                // 更新CSS渲染器（如果有）
                if (labelRenderer) {
                    labelRenderer.setSize(window.innerWidth, window.innerHeight);
                }
                
                // 更新控制面板布局
                adjustPanelLayout();
            }

            // 添加移动端面板切换逻辑
            function togglePanel() {
                const panel = document.getElementById('control-panel');
                panel.classList.toggle('expanded');
                
                const btn = document.querySelector('.mobile-toggle');
                btn.textContent = panel.classList.contains('expanded') ? 
                    '▲ 收起面板' : '▼ 展开面板';
            }

            
            function createRoom(length, height, width) {
            
                const geometry = new THREE.BoxGeometry(length, height, width);
                const mainMaterial = new THREE.MeshPhongMaterial({
                    color: 0xC0C0C0,
                    transparent: true,
                    opacity: 0.25,
                    specular: 0xFFFFFF,
                    shininess: 50,
                    side: THREE.DoubleSide
                });

                const edges = new THREE.EdgesGeometry(geometry);
                const edgeMaterial = new THREE.LineBasicMaterial({
                    color: 0x606060,
                    linewidth: 2
                });
                const roomGroup = new THREE.Group();
                const mainMesh = new THREE.Mesh(geometry, mainMaterial);
                const edgeLines = new THREE.LineSegments(edges, edgeMaterial);
                roomGroup.add(mainMesh);
                roomGroup.add(edgeLines);
                return roomGroup;
            }

            function createScreen(roomLength, roomHeight, roomWidth) {
                const screenRatio = document.getElementById('screenRatio').value;
                const [ratioWidth, ratioHeight] = screenRatio.split('/').map(Number);
                const borderWidth = parseFloat(document.getElementById('screenBorderWidth').value) / 100; // 转换为米
             
                // 手动模式计算
                const screenSizeInch = parseFloat(document.getElementById('screenSize').value) || 0;
                const screenDiagonal = Math.max(screenSizeInch, 30) * 0.0254;
                
                // 基础尺寸计算
                const ratioDiagonal = Math.sqrt(ratioWidth**2 + ratioHeight**2);
                let screenHeight = (screenDiagonal * ratioHeight) / ratioDiagonal;
                let screenWidth = (screenDiagonal * ratioWidth) / ratioDiagonal;
             
                // 应用边框限制
                const maxValidWidth = roomWidth - 2 * borderWidth;
                const maxValidHeight = roomHeight - 2 * borderWidth;
                
                // 自动修正尺寸
                if (screenWidth > maxValidWidth || screenHeight > maxValidHeight) {
                    const widthRatio = maxValidWidth / screenWidth;
                    const heightRatio = maxValidHeight / screenHeight;
                    const adjustRatio = Math.min(widthRatio, heightRatio);
                    
                    screenWidth *= adjustRatio;
                    screenHeight *= adjustRatio;
                    
                    // 更新输入框显示实际尺寸
                    const actualDiagonal = Math.sqrt(screenWidth**2 + screenHeight**2) / 0.0254;
                    document.getElementById('screenSize').value = actualDiagonal.toFixed(1);
                    document.getElementById('screenSize-range').value = actualDiagonal.toFixed(1);
                }

                // 创建投影幕主体
                const screenGeometry = new THREE.PlaneGeometry(screenWidth, screenHeight);
                const screenMaterial = new THREE.MeshPhongMaterial({
                    color: 0x000000,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide
                });
                const screen = new THREE.Mesh(screenGeometry, screenMaterial);

                // 创建边框
                const borderGroup = new THREE.Group();
                if (borderWidth > 0) {
                    const borderMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
                    
                    // 上下边框（带侧边延伸）
                    const horizontalBorderGeometry = new THREE.BoxGeometry(
                        screenWidth + 2 * borderWidth, 
                        borderWidth, 
                        0.01
                    );
                    const topBorder = new THREE.Mesh(horizontalBorderGeometry, borderMaterial);
                    const bottomBorder = topBorder.clone();
                    topBorder.position.y = screenHeight/2 + borderWidth/2;
                    bottomBorder.position.y = -screenHeight/2 - borderWidth/2;

                    // 左右边框（带上下延伸）
                    const verticalBorderGeometry = new THREE.BoxGeometry(
                        borderWidth, 
                        screenHeight + 2 * borderWidth, 
                        0.01
                    );
                    const leftBorder = new THREE.Mesh(verticalBorderGeometry, borderMaterial);
                    const rightBorder = leftBorder.clone();
                    leftBorder.position.x = -screenWidth/2 - borderWidth/2;
                    rightBorder.position.x = screenWidth/2 + borderWidth/2;

                    borderGroup.add(topBorder, bottomBorder, leftBorder, rightBorder);
                }

                // 组合元素
                const screenAssembly = new THREE.Group();
                screenAssembly.add(screen);
                screenAssembly.add(borderGroup);
                
                // 定位到墙面
                screenAssembly.position.set(-roomLength/2 + 0.02, 0, 0);
                screenAssembly.rotation.y = Math.PI/2;

                return screenAssembly;
            }

            // 切换最大屏幕模式
            function toggleMaxScreenMode(isMax) {
                const screenSizeInput = document.getElementById('screenSize');
                const screenSizeRange = document.getElementById('screenSize-range');
             
                // 切换禁用状态
                screenSizeInput.disabled = isMax;
                screenSizeRange.disabled = isMax;
             
                // 样式变化
                screenSizeInput.style.backgroundColor = isMax ? '#eee' : '';
                screenSizeRange.style.opacity = isMax ? 0.5 : 1;
             
                if (isMax) {
                    // 自动计算并显示最大尺寸
                    const roomWidth = parseFloat(document.getElementById('width').value);
                    const roomHeight = parseFloat(document.getElementById('height').value);
                    const borderWidth = parseFloat(document.getElementById('screenBorderWidth').value) / 100;
                    
                    const [ratioW, ratioH] = document.getElementById('screenRatio').value.split('/').map(Number);
                    const availableWidth = roomWidth - 2 * borderWidth;
                    const availableHeight = roomHeight - 2 * borderWidth;
             
                    // 计算最大对角线尺寸（英寸）
                    const maxWidth = availableWidth / (ratioW / Math.sqrt(ratioW**2 + ratioH**2));
                    const maxHeight = availableHeight / (ratioH / Math.sqrt(ratioW**2 + ratioH**2));
                    const maxDiagonal = Math.min(maxWidth, maxHeight) / 0.0254; // 转换为英寸
             
                    screenSizeInput.value = Math.floor(maxDiagonal);
                    screenSizeRange.value = Math.floor(maxDiagonal);
                }
            }

            function updateSpherePosition() {
                const earHeight = parseFloat(document.getElementById('earHeight').value) || 0;
                const viewAngle = parseFloat(document.getElementById('viewAngle').value) || 45;
                const height = parseFloat(document.getElementById('height').value) || 2.7;
                const length = parseFloat(document.getElementById('length').value) || 5.0;

                // 获取屏幕实际尺寸
                if (currentScreen && currentScreen.children.length > 0) {
                    const screenMesh = currentScreen.children[0];
                    const screenWidth = screenMesh.geometry.parameters.width;
                    
                    // 计算观影距离
                    const distance = (screenWidth / 2) / Math.tan((viewAngle / 2) * (Math.PI / 180));
                    const xPosition = distance - length / 2;
                    const yPosition = earHeight - height / 2;
                    
                    sphere.position.set(xPosition, yPosition, 0);
                } else {
                    console.warn("屏幕尚未生成");
                }
            }

            function generateSPK() {

                const length = parseFloat(document.getElementById('length').value) || 5.0;
                const width = parseFloat(document.getElementById('width').value) || 4.0;
                const height = parseFloat(document.getElementById('height').value) || 2.7;
                const earHeight = parseFloat(document.getElementById('earHeight').value) || 1.2;
                const mainSpeakerAngle = parseFloat(document.getElementById('mainSpeakerAngle').value) || 45;
                const sideSurroundAngle = parseFloat(document.getElementById('sideSurroundAngle').value) || 90;
                const rearSurroundAngle = parseFloat(document.getElementById('rearSurroundAngle').value) || 60;
                const frontSkyAngle = parseFloat(document.getElementById('frontSkyAngle').value) || 55;
                const rearSkyAngle = parseFloat(document.getElementById('rearSkyAngle').value) || 125;

                updateSpherePosition(); 
                const sphereX = sphere.position.x;
                const sphereY = sphere.position.y;
                
                if (currentCenterSpeaker) scene.remove(currentCenterSpeaker); 
                if (currentLeftSpeaker) scene.remove(currentLeftSpeaker);
                if (currentRightSpeaker) scene.remove(currentRightSpeaker);
                if (currentSLSpeaker) scene.remove(currentSLSpeaker);
                if (currentSRSpeaker) scene.remove(currentSRSpeaker);
                if (currentSRLSpeaker) scene.remove(currentSRLSpeaker);
                if (currentSRRSpeaker) scene.remove(currentSRRSpeaker);
                if (currentTFLSpeaker) scene.remove(currentTFLSpeaker);
                if (currentTFRSpeaker) scene.remove(currentTFRSpeaker);
                if (currentTRLSpeaker) scene.remove(currentTRLSpeaker); 
                if (currentTRRSpeaker) scene.remove(currentTRRSpeaker);

                // 更新 range 输入框的值
                document.getElementById('length-range').value = length;
                document.getElementById('width-range').value = width;
                document.getElementById('height-range').value = height;
                document.getElementById('earHeight-range').value = earHeight;
                document.getElementById('viewAngle-range').value = document.getElementById('viewAngle').value;
                document.getElementById('mainSpeakerAngle-range').value = mainSpeakerAngle;
                document.getElementById('sideSurroundAngle-range').value = sideSurroundAngle;
                document.getElementById('rearSurroundAngle-range').value = rearSurroundAngle;
                document.getElementById('frontSkyAngle-range').value = frontSkyAngle;
                document.getElementById('rearSkyAngle-range').value = rearSkyAngle;

                


                // 生成中置音箱
                    const centerX = -length / 2 - 0.05; // x轴坐标是房间长度的一半的负值再减去5cm（转换为米）
                    const centerY = earHeight - height/2;
                    const centerZ = 0;
                    const speakerWidth = 0.1;
                    const speakerHeight = 0.2;
                    const speakerDepth = 0.4;

                    const speakerGeometry = new THREE.BoxGeometry(speakerWidth, speakerHeight, speakerDepth);
                    const speakerMaterial = new THREE.MeshPhongMaterial({ color: 0x808080 });

                    currentCenterSpeaker = new THREE.Mesh(speakerGeometry, speakerMaterial);
                    currentCenterSpeaker.speakerType = 'center';
                    currentCenterSpeaker.position.set(centerX, centerY, centerZ);
                    scene.add(currentCenterSpeaker);

                // 生成左声道音箱
                    const leftSpeakerWidth = 0.1;
                    const leftSpeakerHeight = 0.4;
                    const leftSpeakerDepth = 0.2;
                    const leftSpeakerX = -length / 2 - 0.05;
                    const leftSpeakerY = earHeight - height/2;
                    const leftSpeakerZ = Math.tan((mainSpeakerAngle / 2) * (Math.PI / 180)) * (sphere.position.x + length / 2);

                    const leftSpeakerGeometry = new THREE.BoxGeometry(leftSpeakerWidth, leftSpeakerHeight, leftSpeakerDepth);
                    const leftSpeakerMaterial = new THREE.MeshPhongMaterial({ color: 0x808080 });

                    currentLeftSpeaker = new THREE.Mesh(leftSpeakerGeometry, leftSpeakerMaterial);
                    currentLeftSpeaker.speakerType = 'front-left';
                    currentLeftSpeaker.position.set(leftSpeakerX, leftSpeakerY, leftSpeakerZ);
                    scene.add(currentLeftSpeaker);

                // 生成右声道音箱
                    const rightSpeakerWidth = 0.1;
                    const rightSpeakerHeight = 0.4;
                    const rightSpeakerDepth = 0.2;

                    const viewAngle = parseFloat(document.getElementById('viewAngle').value);

                    const rightSpeakerX = -(length / 2) - 0.05;
                    const rightSpeakerY = earHeight - height/2;
                    const rightSpeakerZ = -Math.tan((mainSpeakerAngle / 2) * (Math.PI / 180)) * (sphereX + length / 2);

                    const rightSpeakerGeometry = new THREE.BoxGeometry(rightSpeakerWidth, rightSpeakerHeight, rightSpeakerDepth);
                    const rightSpeakerMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
                    currentRightSpeaker = new THREE.Mesh(rightSpeakerGeometry, rightSpeakerMaterial);
                    currentRightSpeaker.speakerType = 'front-right';
                    currentRightSpeaker.position.set(rightSpeakerX, rightSpeakerY, rightSpeakerZ);
                    scene.add(currentRightSpeaker);

                // 生成左环绕声道音箱
                    const leftSurroundWidth = 0.2;
                    const leftSurroundHeight = 0.4;
                    const leftSurroundDepth = 0.1;
                    const leftSurroundX = Math.tan((sideSurroundAngle - 90) * (Math.PI / 180)) * (width / 2)+sphereX;
                    const leftSurroundY = earHeight - height/2;
                    const leftSurroundZ = width / 2 + 0.05;

                    const leftSurroundGeometry = new THREE.BoxGeometry(leftSurroundWidth, leftSurroundHeight, leftSurroundDepth);
                    const leftSurroundMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
                    currentSLSpeaker = new THREE.Mesh(leftSurroundGeometry, leftSurroundMaterial);
                    currentSLSpeaker.speakerType = 'surround-left';
                    currentSLSpeaker.position.set(leftSurroundX, leftSurroundY, leftSurroundZ);
                    scene.add(currentSLSpeaker);

                // 生成右环绕声道音箱
                    const rightSurroundWidth = 0.2;
                    const rightSurroundHeight = 0.4;
                    const rightSurroundDepth = 0.1;

                    const rightSurroundX = Math.tan((sideSurroundAngle - 90) * (Math.PI / 180)) * (width / 2) + sphereX;
                    const rightSurroundY = earHeight - height/2;
                    const rightSurroundZ = -width / 2 - 0.05;

                    const rightSurroundGeometry = new THREE.BoxGeometry(rightSurroundWidth, rightSurroundHeight, rightSurroundDepth);
                    const rightSurroundMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });

                    currentSRSpeaker = new THREE.Mesh(rightSurroundGeometry, rightSurroundMaterial);
                    currentSRSpeaker.speakerType = 'surround-right';
                    currentSRSpeaker.position.set(rightSurroundX, rightSurroundY, rightSurroundZ);
                    scene.add(currentSRSpeaker);

                // 生成左后环绕声道音箱
                    const leftRearSurroundWidth = 0.1;
                    const leftRearSurroundHeight = 0.4;
                    const leftRearSurroundDepth = 0.2;

                    const leftRearSurroundX = length / 2 + 0.05;
                    const leftRearSurroundY = earHeight - height/2;
                    const leftRearSurroundZ = Math.tan((rearSurroundAngle / 2) * (Math.PI / 180)) * (length / 2 - sphereX);

                    const leftRearSurroundGeometry = new THREE.BoxGeometry(leftRearSurroundWidth, leftRearSurroundHeight, leftRearSurroundDepth);
                    const leftRearSurroundMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });

                    currentSRLSpeaker = new THREE.Mesh(leftRearSurroundGeometry, leftRearSurroundMaterial);
                    currentSRLSpeaker.speakerType = 'rear-left';
                    currentSRLSpeaker.position.set(leftRearSurroundX, leftRearSurroundY, leftRearSurroundZ);
                    scene.add(currentSRLSpeaker);

                // 生成右后环绕声道音箱
                    const rightRearSurroundWidth = 0.1;
                    const rightRearSurroundHeight = 0.4;
                    const rightRearSurroundDepth = 0.2;

                    const rightRearSurroundX = length / 2 + 0.05;
                    const rightRearSurroundY = earHeight - height/2;
                    const rightRearSurroundZ = -Math.tan((rearSurroundAngle / 2) * (Math.PI / 180)) * (length / 2 - sphereX);

                    const rightRearSurroundGeometry = new THREE.BoxGeometry(rightRearSurroundWidth, rightRearSurroundHeight, rightRearSurroundDepth);
                    const rightRearSurroundMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });

                    currentSRRSpeaker = new THREE.Mesh(rightRearSurroundGeometry, rightRearSurroundMaterial);
                    currentSRRSpeaker.speakerType = 'rear-right';
                    currentSRRSpeaker.position.set(rightRearSurroundX, rightRearSurroundY, rightRearSurroundZ);
                    scene.add(currentSRRSpeaker);

                // 生成天空前置左声道音箱
                    const frontSkyLeftRadius = 0.1;
                    const frontSkyLeftHeight = 0.01;

                    const frontSkyLeftX = sphereX - Math.tan(((90 - frontSkyAngle) * Math.PI) / 180) * (height / 2 - sphereY);
                    const frontSkyLeftY = height - height/2;
                    const frontSkyLeftZ = Math.tan(30 * Math.PI / 180) * (height / 2 - sphereY);

                    const frontSkyLeftGeometry = new THREE.CylinderGeometry(frontSkyLeftRadius, frontSkyLeftRadius, frontSkyLeftHeight, 32);
                    const frontSkyLeftMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });

                    currentTFLSpeaker = new THREE.Mesh(frontSkyLeftGeometry, frontSkyLeftMaterial);
                    currentTFLSpeaker.speakerType = 'top-front-left';
                    currentTFLSpeaker.position.set(frontSkyLeftX, frontSkyLeftY, frontSkyLeftZ);
                    scene.add(currentTFLSpeaker);

                // 生成天空前置右声道音箱
                    const frontSkyRightRadius = 0.1;
                    const frontSkyRightHeight = 0.01;

                    const frontSkyRightX = sphereX - Math.tan(((90 - frontSkyAngle) * Math.PI) / 180) * (height / 2 - sphereY);
                    const frontSkyRightY = height - height/2;
                    const frontSkyRightZ = -Math.tan(30 * Math.PI / 180) * (height / 2 - sphereY);

                    const frontSkyRightGeometry = new THREE.CylinderGeometry(frontSkyRightRadius, frontSkyRightRadius, frontSkyRightHeight, 32);
                    const frontSkyRightMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });

                    currentTFRSpeaker = new THREE.Mesh(frontSkyRightGeometry, frontSkyRightMaterial);
                    currentTFRSpeaker.speakerType = 'top-front-right';
                    currentTFRSpeaker.position.set(frontSkyRightX, frontSkyRightY, frontSkyRightZ);
                    scene.add(currentTFRSpeaker);

                // 生成天空后置左声道音箱
                    const rearSkyLeftRadius = 0.1;
                    const rearSkyLeftHeight = 0.01;

                    const rearSkyLeftX = sphereX + Math.tan(((rearSkyAngle - 90) * Math.PI) / 180) * (height / 2 - sphereY);
                    const rearSkyLeftY = height - height/2;
                    const rearSkyLeftZ = Math.tan(30 * Math.PI / 180) * (height / 2 - sphereY);

                    const rearSkyLeftGeometry = new THREE.CylinderGeometry(rearSkyLeftRadius, rearSkyLeftRadius, rearSkyLeftHeight, 32);
                    const rearSkyLeftMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });

                    currentTRLSpeaker = new THREE.Mesh(rearSkyLeftGeometry, rearSkyLeftMaterial);
                    currentTRLSpeaker.speakerType = 'top-rear-left';
                    currentTRLSpeaker.position.set(rearSkyLeftX, rearSkyLeftY, rearSkyLeftZ);
                    scene.add(currentTRLSpeaker);

                // 生成天空后置右声道音箱
                    const rearSkyRightRadius = 0.1;
                    const rearSkyRightHeight = 0.01;

                    const rearSkyRightX = sphereX + Math.tan(((rearSkyAngle - 90) * Math.PI) / 180) * (height / 2 - sphereY);
                    const rearSkyRightY = height - height/2;
                    const rearSkyRightZ = -Math.tan(30 * Math.PI / 180) * (height / 2 - sphereY);

                    const rearSkyRightGeometry = new THREE.CylinderGeometry(rearSkyRightRadius, rearSkyRightRadius, rearSkyRightHeight, 32);
                    const rearSkyRightMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });

                    currentTRRSpeaker = new THREE.Mesh(rearSkyRightGeometry, rearSkyRightMaterial);
                    currentTRRSpeaker.speakerType = 'top-rear-right';
                    currentTRRSpeaker.position.set(rearSkyRightX, rearSkyRightY, rearSkyRightZ);
                    scene.add(currentTRRSpeaker);

                updateSpherePosition();
                    // 初始可见性设置
                    const currentConfig = document.querySelector('input[name="speakerConfig"]:checked').value;
                    updateSpeakerVisibility(currentConfig);

            }

            function generateModel(){
                if (currentRoom) scene.remove(currentRoom);
                if (currentScreen) scene.remove(currentScreen); 

                const length = parseFloat(document.getElementById('length').value) || 5.0;
                const width = parseFloat(document.getElementById('width').value) || 4.0;
                const height = parseFloat(document.getElementById('height').value) || 2.7;

                 if (isNaN(length) || isNaN(width) || isNaN(height)) {
                    console.error("房间尺寸参数无效");
                    return;
                }

                currentRoom = createRoom(length, height, width);
                currentScreen = createScreen(length, height, width);

                scene.add(currentRoom);
                scene.add(currentScreen);

                updateSpherePosition();
                generateSPK();
                updateModelInfo();
            }

            function updateModelInfo() {
                // 获取房间参数
                const length = parseFloat(document.getElementById('length').value) || 0;
                const width = parseFloat(document.getElementById('width').value) || 0;
                const height = parseFloat(document.getElementById('height').value) || 1; // 确保分母不为零
                
                // 计算房间信息
                const area = length * width;
                const volume = length * width * height;

                // 计算比例（高度标准化为1）
                const baseHeight = height || 1; // 防止除零错误
                const lengthRatio = (length / baseHeight).toFixed(2);
                const widthRatio = (width / baseHeight).toFixed(2);
                            
                // 更新显示
                document.getElementById('room-ratio').textContent = 
                    `${lengthRatio}:${widthRatio}:1.00`; // 固定高度显示为1.00
                            
                document.getElementById('room-area').textContent = (length * width).toFixed(2);
                document.getElementById('room-volume').textContent = (length * width * height).toFixed(2);


                // 计算投影幕信息
                const screenSize = parseFloat(document.getElementById('screenSize').value) || 0;
                const ratio = document.getElementById('screenRatio').value.split('/');
                const ratioW = parseFloat(ratio[0]);
                const ratioH = parseFloat(ratio[1]);
                const diagonal = screenSize * 0.0254; // 转换为米
                
                // 根据勾股定理计算实际尺寸
                const screenWidth = (diagonal * ratioW) / Math.sqrt(ratioW**2 + ratioH**2);
                const screenHeight = (diagonal * ratioH) / Math.sqrt(ratioW**2 + ratioH**2);
             
                // 更新显示
                document.getElementById('room-area').textContent = area.toFixed(2);
                document.getElementById('room-volume').textContent = volume.toFixed(2);
                document.getElementById('screen-width').textContent = screenWidth.toFixed(2);
                document.getElementById('screen-height').textContent = screenHeight.toFixed(2);
            }

            // 音箱可见性控制函数
            function updateSpeakerVisibility(config) {
                const activeTypes = speakerConfigMap[config] || [];
                
                [
                    currentCenterSpeaker, currentLeftSpeaker, currentRightSpeaker,
                    currentSLSpeaker, currentSRSpeaker, currentSRLSpeaker,
                    currentSRRSpeaker, currentTFLSpeaker, currentTFRSpeaker,
                    currentTRLSpeaker, currentTRRSpeaker
                ].forEach(speaker => {
                    if (speaker) {
                        speaker.visible = activeTypes.includes(speaker.speakerType);
                    }
                });
            }

            function animate() {
                requestAnimationFrame(animate);
                if(controls) controls.update();
                renderer.render(scene, camera);
                labelRenderer.render(scene, camera);
            }

             
                init();
                generateModel();
                generateSPK();
                animate();

            });
            // 布局调整函数
            function adjustPanelLayout() {
                const infoPanel = document.getElementById('model-info');
                if (window.innerWidth < 768) {
                    infoPanel.style.flexDirection = 'column';
                } else {
                    infoPanel.style.flexDirection = 'row';
                }
            }
    adjustPanelLayout();
    </script>
</body>

</html>